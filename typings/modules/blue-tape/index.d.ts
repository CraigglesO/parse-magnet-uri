// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-es6-promise/fb04188767acfec1defd054fc8024fafa5cd4de7/dist/es6-promise.d.ts
declare module '~blue-tape~es6-promise' {
export interface Thenable <R> {
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Thenable<U>;
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Thenable<U>;
}

export class Promise <R> implements Thenable <R> {
  /**
   * If you call resolve in the body of the callback passed to the constructor,
   * your promise is fulfilled with result object passed to resolve.
   * If you call reject your promise is rejected with the object passed to resolve.
   * For consistency and debugging (eg stack traces), obj should be an instanceof Error.
   * Any errors thrown in the constructor callback will be implicitly passed to reject().
   */
  constructor (callback: (resolve : (value?: R | Thenable<R>) => void, reject: (error?: any) => void) => void);

  /**
   * onFulfilled is called when/if "promise" resolves. onRejected is called when/if "promise" rejects.
   * Both are optional, if either/both are omitted the next onFulfilled/onRejected in the chain is called.
   * Both callbacks have a single parameter , the fulfillment value or rejection reason.
   * "then" returns a new promise equivalent to the value you return from onFulfilled/onRejected after being passed through Promise.resolve.
   * If an error is thrown in the callback, the returned promise rejects with that error.
   *
   * @param onFulfilled called when/if "promise" resolves
   * @param onRejected called when/if "promise" rejects
   */
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Promise<U>;
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Promise<U>;

  /**
   * Sugar for promise.then(undefined, onRejected)
   *
   * @param onRejected called when/if "promise" rejects
   */
  catch <U> (onRejected?: (error: any) => U | Thenable<U>): Promise<U>;

  /**
   * Make a new promise from the thenable.
   * A thenable is promise-like in as far as it has a "then" method.
   */
  static resolve (): Promise<void>;
  static resolve <R> (value: R | Thenable<R>): Promise<R>;

  /**
   * Make a promise that rejects to obj. For consistency and debugging (eg stack traces), obj should be an instanceof Error
   */
  static reject <R> (error: any): Promise<R>;

  /**
   * Make a promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
   * the array passed to all can be a mixture of promise-like objects and other objects.
   * The fulfillment value is an array (in order) of fulfillment values. The rejection value is the first rejection value.
   */
  static all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>, T9 | Thenable<T9>, T10 | Thenable<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;
  static all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>, T9 | Thenable<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;
  static all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;
  static all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;
  static all<T1, T2, T3, T4, T5, T6>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;
  static all<T1, T2, T3, T4, T5>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>]): Promise<[T1, T2, T3, T4, T5]>;
  static all<T1, T2, T3, T4>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>]): Promise<[T1, T2, T3, T4]>;
  static all<T1, T2, T3>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>]): Promise<[T1, T2, T3]>;
  static all<T1, T2>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>]): Promise<[T1, T2]>;
  static all<T1>(values: [T1 | Thenable<T1>]): Promise<[T1]>;
  static all<TAll>(values: Array<TAll | Thenable<TAll>>): Promise<TAll[]>;

  /**
   * Make a Promise that fulfills when any item fulfills, and rejects if any item rejects.
   */
  static race <R> (promises: (R | Thenable<R>)[]): Promise<R>;
}

/**
 * The polyfill method will patch the global environment (in this case to the Promise name) when called.
 */
export function polyfill (): void;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-tape/9746a421d7928ddc84ebcb9d5c3b2a77c38c0b33/index.d.ts
declare module '~blue-tape~tape' {
import { Readable } from 'stream';
import { EventEmitter } from 'events';

/**
 * Create a new test with an optional name string. cb(t) fires with the new test object t once all preceeding tests have finished. Tests execute serially.
 */
function tape (name: string, options: tape.Options, cb: tape.TestCase): tape.Test;
function tape (name: string, cb: tape.TestCase): tape.Test;
function tape (options: tape.Options, cb: tape.TestCase): tape.Test;
function tape (cb: tape.TestCase): tape.Test;

module tape {
  export interface TestCase {
    (test: Test): any;
  }

  export interface Options extends Object {
    skip?: boolean;
    timeout?: number;
  }

  /**
   * Tap compat.
   */
  export const test: typeof tape;

  /**
   * Generate a new test that will be skipped over.
   */
  export function skip (cb: tape.TestCase): tape.Test;
  export function skip (name: string, cb: tape.TestCase): tape.Test;
  export function skip (name: string, options: tape.Options, cb: tape.TestCase): tape.Test;

  /**
   * Like test(name, cb) except if you use .only this is the only test case that will run for the entire process, all other test cases using tape will be ignored
   */
  export function only (name: string, cb: tape.TestCase): tape.Test;
  export function only (name: string, options: tape.Options, cb: tape.TestCase): tape.Test;

  /**
   * Create a new test harness instance, which is a function like test(), but with a new pending stack and test state.
   */
  export function createHarness (): typeof tape;

  /**
   * Create a stream of output, bypassing the default output stream that writes messages to console.log().
   */
  export function createStream (opts?: any): Readable;

  export function onFinish (cb: (err?: Error) => any): void;

  export class Test extends EventEmitter {
    name: string;
    assertCount: number;
    pendingCount: number;

    /**
     * Run the test suite.
     */
    run (): void;

    /**
     * Create a subtest with a new test handle st from cb(st) inside the current test  cb(st) will only fire when t finishes. Additional tests queued up after t will not be run until all subtests finish.
     */
    test (name: string, cb: tape.TestCase): void;

    /**
     * Emit a TAP comment.
     */
    comment (message: string): void;

    /**
     * Declare that n assertions should be run. end() will be called automatically after the nth assertion. If there are any more assertions after the nth, or after end() is called, they will generate errors.
     */
    plan (n: number): void;

    /**
     * Timeout this test after `ms` milliseconds.
     */
    timeoutAfter (ms: number): void;

    /**
     * Declare the end of a test explicitly.
     */
    end (err?: any): void;

    /**
     * Generate a failing assertion with a message msg.
     */
    fail (msg?: string): void;

    /**
     * Generate a passing assertion with a message msg.
     */
    pass (msg?: string): void;

    /**
     * Generate an assertion that will be skipped over.
     */
    skip (msg?: string): void;

    /**
     * Assert that value is truthy with an optional description message msg.
     */
    ok (value: any, msg?: string): void;
    true (value: any, msg?: string): void;
    assert (value: any, msg?: string): void;

    /**
     * Assert that value is falsy with an optional description message msg.
     */
    notOk (value: any, msg?: string): void;
    false (value: any, msg?: string): void;
    notok (value: any, msg?: string): void;

    /**
     * Assert that err is falsy. If err is non-falsy, use its err.message as the description message.
     */
    error (err: any, msg?: string): void;
    ifError (err: any, msg?: string): void;
    ifErr (err: any, msg?: string): void;
    iferror (err: any, msg?: string): void;

    /**
     * Assert that actual === expected with an optional description msg.
     */
    equal (actual: any, expected: any, msg?: string): void;
    equals (actual: any, expected: any, msg?: string): void;
    isEqual (actual: any, expected: any, msg?: string): void;
    is (actual: any, expected: any, msg?: string): void;
    strictEqual (actual: any, expected: any, msg?: string): void;
    strictEquals (actual: any, expected: any, msg?: string): void;

    /**
     * Assert that actual !== expected with an optional description msg.
     */
    notEqual (actual: any, expected: any, msg?: string): void;
    notEquals (actual: any, expected: any, msg?: string): void;
    notStrictEqual (actual: any, expected: any, msg?: string): void;
    notStrictEquals (actual: any, expected: any, msg?: string): void;
    isNotEqual (actual: any, expected: any, msg?: string): void;
    isNot (actual: any, expected: any, msg?: string): void;
    not (actual: any, expected: any, msg?: string): void;
    doesNotEqual (actual: any, expected: any, msg?: string): void;
    isInequal (actual: any, expected: any, msg?: string): void;

    /**
     * Assert that actual and expected have the same structure and nested values using node's deepEqual() algorithm with strict comparisons (===) on leaf nodes and an optional description msg.
     */
    deepEqual (actual: any, expected: any, msg?: string): void;
    deepEquals (actual: any, expected: any, msg?: string): void;
    isEquivalent (actual: any, expected: any, msg?: string): void;
    same (actual: any, expected: any, msg?: string): void;

    /**
     * Assert that actual and expected do not have the same structure and nested values using node's deepEqual() algorithm with strict comparisons (===) on leaf nodes and an optional description msg.
     */
    notDeepEqual (actual: any, expected: any, msg?: string): void;
    notEquivalent (actual: any, expected: any, msg?: string): void;
    notDeeply (actual: any, expected: any, msg?: string): void;
    notSame (actual: any, expected: any, msg?: string): void;
    isNotDeepEqual (actual: any, expected: any, msg?: string): void;
    isNotDeeply (actual: any, expected: any, msg?: string): void;
    isNotEquivalent (actual: any, expected: any, msg?: string): void;
    isInequivalent (actual: any, expected: any, msg?: string): void;

    /**
     * Assert that actual and expected have the same structure and nested values using node's deepEqual() algorithm with loose comparisons (==) on leaf nodes and an optional description msg.
     */
    deepLooseEqual (actual: any, expected: any, msg?: string): void;
    looseEqual (actual: any, expected: any, msg?: string): void;
    looseEquals (actual: any, expected: any, msg?: string): void;

    /**
     * Assert that actual and expected do not have the same structure and nested values using node's deepEqual() algorithm with loose comparisons (==) on leaf nodes and an optional description msg.
     */
    notDeepLooseEqual(actual: any, expected: any, msg?: string): void;
    notLooseEqual (actual: any, expected: any, msg?: string): void;
    notLooseEquals (actual: any, expected: any, msg?: string): void;

    /**
     * Assert that the function call fn() throws an exception.
     */
    throws (fn: () => any, msg?: string): void;
    throws (fn: () => any, expected: RegExp | Function, msg?: string): void;

    /**
     * Assert that the function call fn() does not throw an exception.
     */
    doesNotThrow(fn: () => void, msg?: string): void;
    doesNotThrow(fn: () => void, expected: any, msg?: string): void;

    static skip (cb: tape.TestCase): tape.Test;
    static skip (name: string, cb: tape.TestCase): tape.Test;
    static skip (name: string, options: tape.Options, cb: tape.TestCase): tape.Test;
  }
}

export = tape;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/types/npm-blue-tape/61297708cdff2c892a53474cd5cb77ea3a500205/index.d.ts
declare module 'blue-tape' {
import {Thenable} from '~blue-tape~es6-promise';
import tape = require('~blue-tape~tape');

module '~blue-tape~tape' {
  interface Test {
    shouldFail(p: Thenable<any>, c?: new() => Error): Thenable<any>;
  }
}

export = tape;
}
